package dev.cmedina.desafiomeli.service;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

import org.springframework.stereotype.Service;

import dev.cmedina.desafiomeli.model.Point;

@Service
public class TopSecretService {

	// Satellite position data
	private Map<String, Float[]> satellites = new HashMap<>() {{ 
		put("kenobi", new Float[] {-500f, -200f});
		put("skywalker", new Float[] {100f, -100f});
		put("sato", new Float[] {500f, 100f}); 
	}};
	
	
	 /**
     * Returns a array object with the coordenates 
     * 'x' and 'y' of the message sender.
     *
     * @param  VarArgs with the distance from the transmitter received on each satellite.
     * @return {@code Float[]} values with the coordinates 'x' and 'y' of the message sender.
     * 
     * <p>Returns null if the message cannot be retrieved
     *         
     */
	public Float[] getLocation(Float... distances) {
		
		Optional<Point[]> intersectAB = intersection(satellites.get("kenobi")[0], satellites.get("kenobi")[1], distances[0], satellites.get("skywalker")[0], satellites.get("skywalker")[1], distances[1]);
		Optional<Point[]> intersectBC = intersection(satellites.get("skywalker")[0], satellites.get("skywalker")[1], distances[1], satellites.get("sato")[0], satellites.get("sato")[1], distances[2]);
		Optional<Point[]> intersectAC = intersection(satellites.get("kenobi")[0], satellites.get("kenobi")[1], distances[0], satellites.get("sato")[0], satellites.get("sato")[1], distances[2]);

		Point location = null;
	    
	    if (intersectAB.isPresent() && intersectBC.isPresent() && intersectAC.isPresent()) {
	        for (Point coord : intersectAB.get()) {
	            if (containsCoordInArray(intersectBC.get(), coord) && containsCoordInArray(intersectAC.get(), coord)) {
	                location = coord;
	                break;
	            }    
	        }
	    }
	    
	    if (location == null) return null;
	    
	    return new Float[] { Double.valueOf(location.getRoundedX()).floatValue() , Double.valueOf(location.getRoundedY()).floatValue() };
	    
	}
	
	 /**
     * Returns a array object with the coordenates 
     * 'x' and 'y' of the message sender.
     *
     * @param  the messages that are received (with lag) on each satellite
     * @return {@code String} with the complete message that is generated by the sender.
     * 
     * <p>Returns null if the message cannot be retrieved
     *         
     */
	public String getMessage(String[]... messages) {
		String message = "";
	    try {
	        for (int i = 0; i < messages[0].length; i++) {
	            message += getMessagePart(messages, 0, i) + " ";
	        }
	        return message.trim();
	    } catch (RuntimeException e) {
	        return null;
	    }
	}
	

	// handles possible failures in receiving the message
	private String getMessagePart(String[][] arr, int indexArr, int positionMessage) {
	    if (arr.length <= indexArr) throw new RuntimeException("Não foi possível determinar a mensagem.");
	    return ("".equals(arr[indexArr][positionMessage]) ? getMessagePart(arr, indexArr+1, positionMessage) : arr[indexArr][positionMessage]);
	}
	
	private Optional<Point[]> intersection(double x0, double y0, double r0, double x1, double y1, double r1) {
		
		double dx = x1 - x0;
	    double dy = y1 - y0;
	    
	    double d = Math.sqrt((dy*dy) + (dx*dx));
 
	    /* Check for solvability. */
	    if (d > (r0 + r1)) {
	        /* no solution. circles do not intersect. */
	        return Optional.empty();
	    }
	    if (d < Math.abs(r0 - r1)) {
	        /* no solution. one circle is contained in the other */
	    	return Optional.empty();
	    }
	    
	    /* 'point 2' is the point where the line through the circle
	     * intersection points crosses the line between the circle
	     * centers.  
	     */

	    /* Determine the distance from point 0 to point 2. */
	    double a = ((r0*r0) - (r1*r1) + (d*d)) / (2.0 * d) ;

	    /* Determine the coordinates of point 2. */
	    double x2 = x0 + (dx * a/d);
	    double y2 = y0 + (dy * a/d);

	    /* Determine the distance from point 2 to either of the
	     * intersection points.
	     */
	    double h = Math.sqrt((r0*r0) - (a*a));

	    /* Now determine the offsets of the intersection points from
	     * point 2.
	     */
	    double rx = -dy * (h/d);
	    double ry = dx * (h/d);

	    /* Determine the absolute intersection points. */
	    
	    var pointA = new Point(x2 + rx, y2 + ry);
	    var pointB = new Point(x2 - rx, y2 - ry);
		
	    return Optional.of(new Point[] { pointA, pointB });
		
	}
	
	// Performs the comparison of 2 coordinates
	private boolean compareCoords(Point coordA, Point coordB) {
		return (coordA.getRoundedX() == coordB.getRoundedX() && coordA.getRoundedY() == coordB.getRoundedY());
	}

	// Checks if the coordinate exists in the collection
	private boolean containsCoordInArray(Point[] arr, Point coords) {
		return Arrays.stream(arr).map(item -> compareCoords(item, coords)).filter(val -> val == true).count() > 0;
	}
	
}
