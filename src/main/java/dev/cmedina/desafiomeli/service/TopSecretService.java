package dev.cmedina.desafiomeli.service;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import dev.cmedina.desafiomeli.exception.InvalidMessageException;
import dev.cmedina.desafiomeli.exception.NoEnoughInformationException;
import dev.cmedina.desafiomeli.model.Point;
import dev.cmedina.desafiomeli.model.Position;
import dev.cmedina.desafiomeli.model.ResultSecret;
import dev.cmedina.desafiomeli.model.Satellite;
import dev.cmedina.desafiomeli.model.SatelliteData;
import dev.cmedina.desafiomeli.repository.SatelliteRepository;

@Service
public class TopSecretService {

	
	private SatelliteRepository repository;

	public TopSecretService(@Autowired SatelliteRepository repository) {
		this.repository = repository;
	}

	// Satellite position data
	private static Map<Satellite, Point> satellites = new HashMap<>() {
		{
			put(Satellite.kenobi, new Point(-500f, -200f));
			put(Satellite.skywalker, new Point(100f, -100f));
			put(Satellite.sato, new Point(500f, 100f));
		}
	};

	/**
	 * Returns a array object with the coordenates 'x' and 'y' of the message
	 * sender.
	 *
	 * @param VarArgs with the distance from the transmitter received on each
	 *                satellite.
	 * @return {@code Float[]} values with the coordinates 'x' and 'y' of the
	 *         message sender.
	 * 
	 *         <p>
	 *         Returns null if the message cannot be retrieved
	 * 
	 */
	public Float[] getLocation(Float... distances) {

		Point posKenobi = satellites.get(Satellite.kenobi);
		Point posSkaywalker = satellites.get(Satellite.skywalker);
		Point posSato = satellites.get(Satellite.sato);

		Optional<Point[]> intersectAB = intersection(posKenobi.getX(), posKenobi.getY(), distances[0],
				posSkaywalker.getX(), posSkaywalker.getY(), distances[1]);
		Optional<Point[]> intersectBC = intersection(posSkaywalker.getX(), posSkaywalker.getY(), distances[1],
				posSato.getX(), posSato.getY(), distances[2]);
		Optional<Point[]> intersectAC = intersection(posKenobi.getX(), posKenobi.getY(), distances[0], posSato.getX(),
				posSato.getY(), distances[2]);

		Point location = null;

		if (intersectAB.isPresent() && intersectBC.isPresent() && intersectAC.isPresent()) {
			for (Point coord : intersectAB.get()) {
				if (containsCoordInArray(intersectBC.get(), coord) && containsCoordInArray(intersectAC.get(), coord)) {
					location = coord;
					break;
				}
			}
		}

		if (location == null)
			return null;

		return new Float[] { Double.valueOf(location.getRoundedX()).floatValue(),
				Double.valueOf(location.getRoundedY()).floatValue() };

	}

	/**
	 * Returns a array object with the coordenates 'x' and 'y' of the message
	 * sender.
	 *
	 * @param the messages that are received (with lag) on each satellite
	 * @return {@code String} with the complete message that is generated by the
	 *         sender.
	 * 
	 *         <p>
	 *         Returns null if the message cannot be retrieved
	 * 
	 */
	public String getMessage(String[]... messages) throws InvalidMessageException {
		String message = "";
		for (int i = 0; i < messages[0].length; i++) {
			message += getMessagePart(messages, 0, i) + " ";
		}
		return message.trim();
	}

	public void receiveSatelliteMessage(SatelliteData data) {
		repository.insert(data);
	}

	public Optional<ResultSecret> getLocationAndMessage() throws NoEnoughInformationException, InvalidMessageException {

		Collection<SatelliteData> list = repository.findAll();
		
		if (list.size() != Satellite.values().length) {
			throw new NoEnoughInformationException();
		}

		var distances = new Float[list.size()];
		var messages = new String[list.size()][];
		
		int i = 0;
		
		for (Satellite satellite: Satellite.values()) {
			SatelliteData row = repository.findByName(satellite.toString());
			distances[i] = row.distance();
			messages[i] = row.message();
			i++;
		}

		Float[] location = getLocation(distances);
		String message = getMessage(messages);

		repository.clear();

		// If the location could not be determined
		// then return: RESPONSE CODE: 404
		if (location == null || message == null) {
			return Optional.empty();
		}

		Position position = new Position(location[0], location[1]);

		return Optional.of(new ResultSecret(position, message));

	}

	// handles possible failures in receiving the message
	private String getMessagePart(String[][] arr, int indexArr, int positionMessage) throws InvalidMessageException {
		if (arr.length <= indexArr)
			throw new InvalidMessageException();
		return ("".equals(arr[indexArr][positionMessage]) ? getMessagePart(arr, indexArr + 1, positionMessage)
				: arr[indexArr][positionMessage]);
	}

	private Optional<Point[]> intersection(double x0, double y0, double r0, double x1, double y1, double r1) {

		double dx = x1 - x0;
		double dy = y1 - y0;

		double d = Math.sqrt((dy * dy) + (dx * dx));

		/* Check for solvability. */
		if (d > (r0 + r1)) {
			/* no solution. circles do not intersect. */
			return Optional.empty();
		}
		if (d < Math.abs(r0 - r1)) {
			/* no solution. one circle is contained in the other */
			return Optional.empty();
		}

		/*
		 * 'point 2' is the point where the line through the circle intersection points
		 * crosses the line between the circle centers.
		 */

		/* Determine the distance from point 0 to point 2. */
		double a = ((r0 * r0) - (r1 * r1) + (d * d)) / (2.0 * d);

		/* Determine the coordinates of point 2. */
		double x2 = x0 + (dx * a / d);
		double y2 = y0 + (dy * a / d);

		/*
		 * Determine the distance from point 2 to either of the intersection points.
		 */
		double h = Math.sqrt((r0 * r0) - (a * a));

		/*
		 * Now determine the offsets of the intersection points from point 2.
		 */
		double rx = -dy * (h / d);
		double ry = dx * (h / d);

		/* Determine the absolute intersection points. */

		var pointA = new Point(x2 + rx, y2 + ry);
		var pointB = new Point(x2 - rx, y2 - ry);

		return Optional.of(new Point[] { pointA, pointB });

	}

	// Performs the comparison of 2 coordinates
	private boolean compareCoords(Point coordA, Point coordB) {
		return (coordA.getRoundedX() == coordB.getRoundedX() && coordA.getRoundedY() == coordB.getRoundedY());
	}

	// Checks if the coordinate exists in the collection
	private boolean containsCoordInArray(Point[] arr, Point coords) {
		return Arrays.stream(arr).map(item -> compareCoords(item, coords)).filter(val -> val == true).count() > 0;
	}

}
